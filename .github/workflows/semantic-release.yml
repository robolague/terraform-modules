name: Semantic Release

on:
  push:
    branches:
      - main

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  release:
    name: Release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install conventional-changelog
        run: |
          pip install conventional-changelog

      - name: Analyze commits and create release
        run: |
          # Get the latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"

          # Get commits since last tag
          COMMITS=$(git log --pretty=format:"%H %s" ${LATEST_TAG}..HEAD)
          echo "Commits since last tag:"
          echo "$COMMITS"

          # Analyze commit types
          MAJOR=false
          MINOR=false
          PATCH=false

          while IFS= read -r commit; do
            if [[ $commit =~ ^[a-f0-9]+[[:space:]](feat|fix|docs|style|refactor|perf|test|chore)(\(.+\))?!?: ]]; then
              # Breaking change
              MAJOR=true
              echo "Found breaking change in commit: $commit"
            elif [[ $commit =~ ^[a-f0-9]+[[:space:]](feat)(\(.+\))?: ]]; then
              # New feature
              MINOR=true
              echo "Found new feature in commit: $commit"
            elif [[ $commit =~ ^[a-f0-9]+[[:space:]](fix|docs|style|refactor|perf|test|chore)(\(.+\))?: ]]; then
              # Bug fix or other changes
              PATCH=true
              echo "Found patch change in commit: $commit"
            fi
          done <<< "$COMMITS"

          # Determine version bump
          CURRENT_VERSION=$(echo $LATEST_TAG | sed 's/^v//')
          IFS='.' read -r MAJOR_VERSION MINOR_VERSION PATCH_VERSION <<< "$CURRENT_VERSION"

          if [ "$MAJOR" = true ]; then
            NEW_MAJOR=$((MAJOR_VERSION + 1))
            NEW_VERSION="${NEW_MAJOR}.0.0"
            RELEASE_TYPE="major"
          elif [ "$MINOR" = true ]; then
            NEW_MINOR=$((MINOR_VERSION + 1))
            NEW_VERSION="${MAJOR_VERSION}.${NEW_MINOR}.0"
            RELEASE_TYPE="minor"
          elif [ "$PATCH" = true ]; then
            NEW_PATCH=$((PATCH_VERSION + 1))
            NEW_VERSION="${MAJOR_VERSION}.${MINOR_VERSION}.${NEW_PATCH}"
            RELEASE_TYPE="patch"
          else
            echo "No conventional commits found, skipping release"
            exit 0
          fi

          echo "Current version: $CURRENT_VERSION"
          echo "New version: $NEW_VERSION"
          echo "Release type: $RELEASE_TYPE"

          # Create new tag
          NEW_TAG="v${NEW_VERSION}"
          git tag $NEW_TAG
          git push origin $NEW_TAG

          # Create GitHub release
          gh release create $NEW_TAG \
            --title "Release $NEW_TAG" \
            --notes "## What's Changed

          $(git log --pretty=format:"* %s" ${LATEST_TAG}..HEAD | grep -v "chore(release)" | head -20)

          ## Version Changes
          * **Release Type:** $RELEASE_TYPE
          * **Previous Version:** $CURRENT_VERSION
          * **New Version:** $NEW_VERSION

          ---

          This release was automatically generated based on conventional commit messages." \
            --generate-notes

          echo "Created release: $NEW_TAG"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
